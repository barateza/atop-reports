# ATOP Resource Monitor - AI Agent Instructions

## Project Overview
Production-hardened bash script that monitors Plesk server resources (CPU, memory, disk I/O) using `atop`. Captures 15-second snapshots when thresholds are exceeded, generates ranked reports of resource offenders. Designed for fleet deployment via Ansible/Puppet.

**Current Version:** 2.0.0 (January 16, 2026)

**Key Files:**
- [atop-reports.sh](../atop-reports.sh) - Main monitoring script (882 lines)
- [atop-reports.conf.example](../atop-reports.conf.example) - Config template for `/etc/atop-reports.conf`
- [README.md](../README.md) - User documentation and architecture decisions
- [IMPLEMENTATION_v2.0.md](../IMPLEMENTATION_v2.0.md) - v2.0 dynamic header detection & Container ID support
- [MIGRATION.md](../MIGRATION.md) - v1.1 → v2.0 migration guide (breaking changes)
- [TESTING_STATUS.md](../TESTING_STATUS.md) - CI/CD test results across Ubuntu 18.04-24.04

## Critical Architecture Patterns

### v2.0 Dynamic Header Detection
ALL atop parsing MUST use dynamic column detection to avoid field position brittleness:
```awk
# Parse header to build dynamic column map
$1 ~ /^(PRG|PRC|PRM|PRD|DSK)$/ && NF > 10 && $7 !~ /^[0-9]+$/ {
    type = $1
    for (i = 1; i <= NF; i++) {
        col_map[type, toupper($i)] = i
    }
    next
}

# Use dynamic column lookup in data lines
/^PRG/ && $7 ~ /^[0-9]+$/ {
    pid = $(col_map["PRG", "PID"])
    cmd_name = $(col_map["PRG", "NAME"])
    cid = $(col_map["PRG", "CID"])  # atop 2.7.1+ only
}
```
**Why:** atop field positions vary between versions (2.3.0: 17 CPU fields, 2.4.0+: 21 CPU fields). Dynamic detection eliminates hardcoded `$7`, `$8` assumptions.

**Fallback mechanism:** If dynamic detection fails, script falls back to version-based maps (FIELD_MAP_V23, FIELD_MAP_V24, FIELD_MAP_V27) defined at lines 255-279.

### Resource Lifecycle Management
ALL temp resources MUST be tracked for cleanup via trap handlers:
```bash
# Create temp file
SNAPSHOT_FILE=$(mktemp -t atop-snapshot.XXXXXX)
chmod 600 "$SNAPSHOT_FILE"
CLEANUP_FILES+=("$SNAPSHOT_FILE")  # Track for cleanup

# Create temp directory
temp_dir=$(mktemp -d -t atop-parse.XXXXXX)
chmod 700 "$temp_dir"
CLEANUP_DIRS+=("$temp_dir")  # Track for cleanup
```
The `cleanup()` function (lines 195-226) iterates these arrays on EXIT/TERM/INT/HUP signals.

### ShellCheck Compliance (Zero Warnings Required)
- **SC2155:** Separate declaration from assignment:
  ```bash
  # WRONG
  local result=$(some_command)
  
  # CORRECT
  local result
  result=$(some_command)
  ```
- **SC2129:** Group multiple redirects:
  ```bash
  # WRONG
  echo "Line 1" >> "$LOG_FILE"
  echo "Line 2" >> "$LOG_FILE"
  
  # CORRECT
  {
      echo "Line 1"
      echo "Line 2"
  } >> "$LOG_FILE"
  ```
- **Portable AWK over grep -oP:** This script uses GNU coreutils but runs on BSD/macOS too. Use `awk` pattern matching instead of `grep -P` for regex.

### Hybrid Configuration Philosophy
Script works out-of-box with inline defaults (lines 63-89) but loads `/etc/atop-reports.conf` if present (lines 95-100). This enables:
- **Quick diagnosis:** Download and run immediately
- **Fleet deployment:** Ansible/Puppet pushes custom configs

When adding new config variables, add both inline default and document in [atop-reports.conf.example](../atop-reports.conf.example).

### Disk I/O Percentage (Relative Scaling)
Disk % is calculated relative to heaviest process, NOT absolute hardware limits:
```bash
# In AWK (lines 493-501)
max_disk_total = max disk usage across all processes
disk_percent[pid] = (pid_disk_usage / max_disk_total) * 100
```
**Rationale:** NVMe vs HDD have vastly different throughput. Relative scaling creates hardware-agnostic "Heaviest Offender Index" (see README lines 241-249).

### Non-Blocking Metrics Collection
System metrics MUST NOT block monitoring loop. CPU I/O wait calculated via dual `/proc/stat` samples (lines 760-785):
```bash
# Before: vmstat 1 2 → 2s blocking delay
# After: /proc/stat sampling → 0.1s delay (95% reduction)
grep '^cpu ' /proc/stat  # Sample 1
sleep 0.1
grep '^cpu ' /proc/stat  # Sample 2
# Calculate delta manually
```

## Test Fixture Management

### Automated Fixture Generation
The project uses golden master fixtures for cross-version testing. These fixtures are binary atop snapshots captured from VMs running specific Ubuntu versions.

**Fixture Generation Script:** `tests/generate-all-fixtures.sh`

**Full Workflow (40-60 minutes):**
```bash
cd /path/to/atop-reports
./tests/generate-all-fixtures.sh

# What happens internally:
# 1. For each Ubuntu version (18.04, 20.04, 22.04, 24.04):
#    - Launch Multipass VM with appropriate image
#    - Wait for SSH readiness (with retry logic)
#    - Update APT cache (apt-get update)
#    - Install atop package from official repos
#    - Verify atop version matches expected
#    - Capture 15-second snapshot: atop -w /tmp/fixture.raw 15 1
#    - Transfer fixture to host: tests/fixtures/v{VERSION}-ubuntu{VERSION}.raw
#    - Delete VM and purge storage
# 2. All fixtures written to tests/fixtures/
# 3. Each fixture: 5-20MB (depends on system load)
```

**Generate single version only:**
```bash
./tests/generate-all-fixtures.sh --version 22.04
# Generates only Ubuntu 22.04 fixture (atop 2.7.1)
# Useful for testing specific version changes
# Time: ~10-15 minutes
```

**Manual Fixture Generation (if automation fails):**
```bash
# Example: Ubuntu 20.04
multipass launch focal --name atop-focal --memory 1G --disk 5G
multipass exec atop-focal -- sudo apt-get update -qq
multipass exec atop-focal -- sudo apt-get install -y -qq atop
multipass exec atop-focal -- sudo atop -w /tmp/fixture.raw 15 1
multipass transfer atop-focal:/tmp/fixture.raw ./tests/fixtures/v2.4.0-ubuntu20.04.raw
multipass delete atop-focal --purge
```

**Supported Versions:**
| Ubuntu | Codename | atop Version | Fixture File |
|--------|----------|--------------|--------------|
| 18.04  | bionic   | 2.3.0        | v2.3.0-ubuntu18.04.raw |
| 20.04  | focal    | 2.4.0        | v2.4.0-ubuntu20.04.raw |
| 22.04  | jammy    | 2.7.1        | v2.7.1-ubuntu22.04.raw |
| 24.04  | noble    | 2.10.0       | v2.10.0-ubuntu24.04.raw |

**Important Notes:**
- Ubuntu 22.04+ use version numbers (`22.04`) not codenames (`jammy`) in Multipass
- atop 2.7.1+ includes Container ID field (Field 17 in PRG label)
- Fixtures are binary format - use `atop -r` to convert to text
- Each fixture contains 15 samples (1 per second) from idle VM

### Docker Compose Testing
After generating fixtures, validate with Docker:

```bash
# Test all versions
docker-compose up --abort-on-container-exit

# Test single version
docker-compose run --rm test-bionic   # Ubuntu 18.04
docker-compose run --rm test-focal    # Ubuntu 20.04
docker-compose run --rm test-jammy    # Ubuntu 22.04
docker-compose run --rm test-noble    # Ubuntu 24.04
```

**Test Coverage per Version:**
- Text output format validation
- JSON schema v2.0 validation
- Container ID field presence (null-safe)
- Verbose mode execution
- Dynamic header detection
- Version fallback mechanism

### Automated Fixture Generation
The project uses golden master fixtures for cross-version testing. These fixtures are binary atop snapshots captured from VMs running specific Ubuntu versions.

**Fixture Generation Script:** `tests/generate-all-fixtures.sh`

**Generate all fixtures:**
```bash
cd /path/to/atop-reports
./1. Syntax validation
bash -n atop-reports.sh

# 2. ShellCheck (must be CLEAN)
shellcheck atop-reports.sh

# 3. Test replay mode with existing fixture
atop -r tests/fixtures/v2.3.0-ubuntu18.04.raw -P PRG,PRC,PRM,PRD,DSK > /tmp/test.txt
./atop-reports.sh --file /tmp/test.txt
./atop-reports.sh --file /tmp/test.txt --json | jq .

# 4. Test signal handling (verify cleanup)
sudo ./atop-reports.sh &
PID=$!
sleep 5
sudo kill -TERM $PID
ls /run/lock/atop-reports.lock  # Should NOT exist

# 5. Run Docker Compose test suite (after code changes)
docker-compose run --rm test-bionic   # Test v2.3.0
docker-compose run --rm test-focal    # Test v2.4.0
docker-compose run --rm test-jammy    # Test v2.7.1 (with Container ID)
docker-compose run --rm test-noble    # Test v2.10.0

# 6. Regenerate fixtures if AWK parsing logic changed
./tests/generate-all-fixtures.sh
docker-compose up --abort-on-container-exit  # Validate all versions

# 7. Test on real system with live data
sudo atop -P PRG,PRC,PRM,PRD,DSK 1 15 > /tmp/live.txt
./atop-reports.sh --file /tmp/live.txt --verbose
```

**Version-Specific Testing Notes:**
- v2.3.0 (Ubuntu 18.04): No Container ID, tests null handling
- v2.4.0 (Ubuntu 20.04): Transition version, no major field changes
- v2.7.1 (Ubuntu 22.04): Container ID field added (Field 17), tests CID extraction
- v2.10.0 (Ubuntu 24.04): Latest format, most comprehensive test
**Manual Fixture Generation (if automation fails):**
```bash
# Example: Ubuntu 20.04
multipass launch focal --name atop-focal --memory 1G --disk 5G
multipass exec atop-focal -- sudo apt-get update -qq
multipass exec atop-focal -- sudo apt-get install -y -qq atop
multipass exec atop-focal -- sudo atop -w /tmp/fixture.raw 15 1
multipass transfer atop-focal:/tmp/fixture.raw ./tests/fixtures/v2.4.0-ubuntu20.04.raw
multipass delete atop-focal --purge
```

**Supported Versions:**
| Ubuntu | Codename | atop Version | Fixture File |
|--------|----------|--------------|--------------|
| 18.04  | bionic   | 2.3.0        | v2.3.0-ubuntu18.04.raw |
| 20.04  | focal    | 2.4.0        | v2.4.0-ubuntu20.04.raw |
| 22.04  | jammy    | 2.7.1        | v2.7.1-ubuntu22.04.raw |
| 24.04  | noble    | 2.10.0       | v2.10.0-ubuntu24.04.raw |

**Important Notes:**
- Ubuntu 22.04+ use version numbers (`22.04`) not codenames (`jammy`) in Multipass
- atop 2.7.1+ includes Container ID field (Field 17 in PRG label)
- Fixtures are binary format - use `atop -r` to convert to text
- Each fixture contains 15 samples (1 per second) from idle VM

### Docker Compose Testing
After generating fixtures, validate with Docker:

```bash
# Test all versions
docker-compose up --abort-on-container-exit

# Test single version
docker-compose run --rm test-bionic   # Ubuntu 18.04
docker-compose run --rm test-focal    # Ubuntu 20.04
docker-compose run --rm test-jammy    # Ubuntu 22.04
docker-compose run --rm test-noble    # Ubuntu 24.04
```

**Test Coverage per Version:**
- Text output format validation
- JSON schema v2.0 validation
- Container ID field presence (null-safe)
- Verbose mode execution
- Dynamic header detection
- Version fallback mechanism

## Common Development Tasks

### Adding New Metrics
1. Parse from atop output in `parse_atop_output()` AWK block (lines 295-575)
2. Add to process scoring algorithm (lines 489-501)
3. Update JSON schema version if adding fields to `data.processes[]`
4. Document in README JSON Schema section (lines 163-191)

### Testing Changes
```bash
# 1. Syntax validation
bash -n atop-reports.sh

# 2. ShellCheck (must be CLEAN)
shellcheck atop-reports.sh

# 3. Test replay mode with existing fixture
atop -r tests/fixtures/v2.3.0-ubuntu18.04.raw -P PRG,PRC,PRM,PRD,DSK > /tmp/test.txt
./atop-reports.sh --file /tmp/test.txt
./atop-reports.sh --file /tmp/test.txt --json | jq .

# 4. Test signal handling (verify cleanup)
sudo ./atop-reports.sh &
PID=$!
sleep 5
sudo kill -TERM $PID
ls /run/lock/atop-reports.lock  # Should NOT exist

# 5. Run Docker Compose test suite (after code changes)
docker-compose run --rm test-bionic   # Test v2.3.0
docker-compose run --rm test-focal    # Test v2.4.0
docker-compose run --rm test-jammy    # Test v2.7.1 (with Container ID)
docker-compose run --rm test-noble    # Test v2.10.0

# 6. Regenerate fixtures if AWK parsing logic changed
./tests/generate-all-fixtures.sh
docker-compose up --abort-on-container-exit  # Validate all versions

# 7. Test on real system with live data
sudo atop -P PRG,PRC,PRM,PRD,DSK 1 15 > /tmp/live.txt
./atop-reports.sh --file /tmp/live.txt --verbose
```

**Version-Specific Testing Notes:**
- v2.3.0 (Ubuntu 18.04): No Container ID, tests null handling
- v2.4.0 (Ubuntu 20.04): Transition version, no major field changes
- v2.7.1 (Ubuntu 22.04): Container ID field added (Field 17), tests CID extraction
- v2.10.0 (Ubuntu 24.04): Latest format, most comprehensive test

### Modifying AWK Processing
The `parse_atop_output()` function (lines 287-576) processes atop's structured output using the **Parseable (-P) format**, which is space-delimited and position-dependent.

**Structured Output Format Used:**
```bash
atoRun Docker Compose tests on all 4 versions
7. Regenerate fixtures if AWK parsing logic modified
8. Update IMPLEMENTATION_v2.0.md for breaking changes
9. Test with both --json and text output formats
10. Verify verbose mode if modifying Container ID logic``

**Label Types and Field Positions:**
- **PRG (Process General):** Fields 7=PID, 8=CommandName, 9-15=metadata
  - Field 17+ (Container ID) only available in atop 2.7+
- **PRC (CPU metrics):** Fields 7=PID, 11=user_ticks, 12=sys_ticks
  - Total CPU ticks = user_ticks + sys_ticks
- **PRM (Memory metrics):** Fields 7=PID, 11=RSS (KB)
  - Direct mapping to resident memory
- **PRD (Disk I/O):** Fields 7=PID, 12=sectors_read, 14=sectors_write
  - Convert sectors to KB: sectors × 0.5 (512 bytes/sector)
- **DSK (System disk):** Fields 9=sectors_read, 11=sectors_write
  - System-level aggregation for unattributed I/O

**Critical Parsing Rules:**
1. **Position-Dependent:** Field meaning determined by index, not labels
2. **Version-Sensitive:** Field positions shift between atop versions
   - atop 2.3.0 (Ubuntu 18.04): 17 CPU fields
   - atop 2.4.0+ (Ubuntu 20.04+): 21 CPU fields (added frequency/IPC)
3. **AWK Arrays:** MUST use PID as index: `prc_cpu_sum[pid]`, `prm_mem_peak[pid]`
4. **Sample Counting:** Track samples via `/^SEP/` delimiter to calculate averages

### Website Identification Logic
The `get_parent_info()` function (lines 642-741) extracts website/vhost details from process command lines:

**PHP-FPM pool detection:**
```bash
# Extract from cmdline like: php-fpm: pool www or pool=example.com
pool=$(echo "$cmdline" | awk -F'pool[= ]' 'NF>1 {print $2}' | awk '{print $1}')
if [ -z "$pool" ]; then
    pool=$(echo "$cmdline" | awk -F'php-fpm: pool ' 'NF>1 {print $2}' | awk '{print $1}')
fi
```

**Apache vhost detection:**
```bash
# Extract from -D flags or .conf file paths
vhost=$(echo "$cmdline" | awk '/-D.*VHOST/ {for(i=1;i<=NF;i++) if($i ~ /^-D.*VHOST/) print $i}' | head -1)
if [ -z "$vhost" ]; then
    vhost=$(echo "$cmdline" | awk -F'-f ' 'NF>1 {print $2}' | awk '{match($0, /\/([^\/]+\.conf)/, a); print a[1]}')
fi
```

**Parent process name:**
```bash
# Skip systemd/init, only show meaningful parents
ppid=$(grep '^PPid:' "/proc/$pid/status" 2>/dev/null | awk '{print $2}')
if [ -n "$ppid" ] && [ "$ppid" -gt 1 ]; then
    parent_name=$(cat "/proc/$ppid/comm" 2>/dev/null)
    # Filter out systemd/init
fi
```

**Output format:** `[pool: example.com, vhost: site.conf, parent: apache2]`

This information appears in text reports after process names to help identify which website is consuming resources.

## Error Handling Conventions

### Validation Pattern (All User Inputs)
```bash
if ! [[ $VALUE =~ ^[0-9]+\.?[0-9]*$ ]] || [ "$VALUE" -lt 0 ]; then
    echo "ERROR: Invalid value: $VALUE" >&2
    exit 1
fiCode Quality Standards

### Function Length Limit
**Hard requirement:** Functions MUST NOT exceed 150 lines for maintainability and readability.

If refactoring a function that exceeds this limit:
1. Extract logical sections into helper functions
2. Use clear, descriptive function names
3. Maintain single responsibility principle
4. Document helper functions with comments

Example refactoring approach:
```bash
# BEFORE: 200-line parse_atop_output() function

# AFTER: Split into logical components
parse_atop_output() {
    validate_snapshot_file "$snapshot_file"
    parse_process_metrics "$snapshot_file"
    calculate_scores_and_ranks "$temp_dir"
    format_output "$report_file"
}
```

### Checklist for All Changes
1. Preserve ShellCheck cleanliness (zero warnings)
2. Track all temp resources in CLEANUP arrays
3. Test both root and non-root execution
4. Verify trap handlers work with `kill -TERM`
5. Keep functions under 150 lines
6. Update IMPLEMENTATION_SUMMARY.md for significant changes
7
### Lock File Protection
Single-instance enforcement via flock (lines 177-192):
```bash
exec 200>"$LOCK_FILE"
if ! flock -n 200; then
    echo "ERROR: Another instance already running" >&2
    exit 1
fi
```
Lock released automatically by `cleanup()` trap handler.

## JSON Output Contract
Schema version 2.0 with metadata envelope and Container ID support (lines 533-575). Breaking changes require version bump to 3.0. Field additions don't require version change (forward-compatible parsers ignore unknown fields).

**Null Safety:** Use `null` for unavailable metrics (e.g., disk I/O in LIMITED_MODE, Container ID in atop < 2.7.1), never omit fields or use placeholder strings.

**v2.0 Schema Example:**
```json
{
  "meta": {
    "schema_version": "2.0",
    "timestamp": "2026-01-16T14:30:00Z",
    "hostname": "server.example.com",
    "mode": "full"
  },
  "data": {
    "processes": [{
      "process": "nginx",
      "container_id": "abc123def456",  // null if N/A
      "avg": {"cpu_percent": 45.2, ...},
      "peak": {"cpu_percent": 78.1, ...}
    }]
  }
}
```

## Production Deployment Notes
- **Systemd integration:** Script loops infinitely; suitable for `Type=simple` service
- **Log rotation:** Append-only to `LOG_FILE`; configure logrotate separately
- **Memory usage:** ~50-100MB typical, up to 200MB with 10,000+ processes
- **Alert cooldown:** `COOLDOWN` period prevents log spam during sustained incidents

## Official Deployment Targets

The script is designed for Plesk-supported operating systems with atop installed from official repositories:

### Ubuntu
- **24.04 LTS (Recommended):** atop 2.10.0
- **22.04 LTS (incl. ARM):** atop 2.7.1
- **20.04 LTS:** atop 2.4.0
- **18.04 LTS:** atop 2.3.0

### Debian
- **13 (Testing/Trixie):** atop 2.11.1
- **12 (Bookworm):** atop 2.8.1
- **11 (Bullseye):** atop 2.6.0
- **10 (Buster):** atop 2.4.0

### AlmaLinux / RHEL / CloudLinux / CentOS
- **AlmaLinux 8.x / RHEL 8.x:** atop 2.7.1
- **CloudLinux 9.x / 8.x:** atop 2.7.1
- **CloudLinux 7.x / CentOS 7.x:** atop 2.7.1

**Minimum version:** 2.3.0 for structured output (`-P` flag support)

## Common Test Infrastructure Issues

### Fixture Generation Problems

**Issue: Multipass VM Launch Fails**
```
ERROR: Failed to launch VM: timeout waiting for initialization
```
**Root Cause:** Hypervisor not running, network timeout, or resource exhaustion
**Solutions:**
```bash
# Check Multipass daemon status
multipass version
multipass list  # Should show running VMs

# Restart Multipass service (macOS)
sudo launchctl kickstart -k system/com.canonical.multipassd

# Restart Multipass service (Linux)
sudo systemctl restart multipass.multipassd

# Check available resources
multipass info --all  # Shows CPU/memory usage

# Delete stale VMs
multipass delete --all --purge

# Last resort: Reinstall Multipass
brew reinstall multipass  # macOS
```

**Issue: SSH Readiness Timeout**
```
Waiting for SSH...... (60 attempts)
ERROR: VM never became SSH-ready
```
**Root Cause:** VM networking not initialized, firewall blocking, or slow VM boot
**Solutions:**
```bash
# Increase retry timeout in generate-all-fixtures.sh
# Change: MAX_RETRIES=60 to MAX_RETRIES=120

# Check VM status manually
multipass list  # Should show "Running"
multipass exec vm-name -- echo "test"  # Test SSH directly

# Check network connectivity
multipass exec vm-name -- ping -c 3 8.8.8.8

# If using VPN: Disable VPN and retry (Multipass + VPN = conflicts)
```

**Issue: APT Package Installation Fails**
```
E: Unable to locate package atop
```
**Root Cause:** APT cache not updated, wrong Ubuntu version, or mirror issues
**Solutions:**
```bash
# Update APT cache manually
multipass exec vm-name -- sudo apt-get update
multipass exec vm-name -- sudo apt-cache search atop

# Check Ubuntu version in VM
multipass exec vm-name -- cat /etc/os-release

# Try different Ubuntu mirror
multipass exec vm-name -- sudo sed -i 's|archive.ubuntu.com|mirror.example.com|g' /etc/apt/sources.list
multipass exec vm-name -- sudo apt-get update
```

**Issue: Fixture File Empty or Corrupt**
```
Fixture size: 0 bytes
```
**Root Cause:** atop capture failed (permissions, no activity, or interrupted)
**Solutions:**
```bash
# Verify atop works in VM
multipass exec vm-name -- sudo atop 1 1  # Should show metrics

# Check VM has process activity
multipass exec vm-name -- ps aux | wc -l  # Should be > 50

# Generate synthetic load during capture
multipass exec vm-name -- sudo sh -c 'stress-ng --cpu 2 --vm 1 --vm-bytes 256M --timeout 30s & atop -w /tmp/fixture.raw 15 1'

# Verify fixture before transfer
multipass exec vm-name -- ls -lh /tmp/fixture.raw
multipass exec vm-name -- file /tmp/fixture.raw  # Should show "data"
```

### Docker Compose Test Failures

**Issue: Docker Container Won't Start**
```
ERROR: for test-jammy  Cannot start service test-jammy: ...
```
**Root Cause:** Docker not running, image pull failed, or volume mount issue
**Solutions:**
```bash
# Check Docker daemon
docker info  # Should show server version
sudo systemctl start docker  # Linux
open -a Docker  # macOS Docker Desktop

# Pull images manually
docker pull ubuntu:18.04
docker pull ubuntu:20.04
docker pull ubuntu:22.04
docker pull ubuntu:24.04

# Check volume mounts
ls -la tests/fixtures/  # Files must exist
chmod 644 tests/fixtures/*.raw  # Ensure readable
```

**Issue: Test Script Not Found**
```
/tests/run-test.sh: No such file or directory
```
**Root Cause:** Volume mount misconfiguration or incorrect working directory
**Solutions:**
```bash
# Verify volume mounts in docker-compose.yml
grep -A2 "volumes:" docker-compose.yml
# Should show:
#   - .:/app
#   - ./tests:/tests

# Check file exists on host
ls -la tests/run-test.sh
chmod +x tests/run-test.sh  # Ensure executable

# Test mount directly
docker-compose run test-jammy ls -la /tests/
```

**Issue: Fixture Not Found in Container**
```
[3/5] Checking fixture availability...
✗ ERROR: Fixture not found: /tests/fixtures/v2.7.1-ubuntu22.04.raw
```
**Root Cause:** Fixture not generated, wrong filename, or mount path issue
**Solutions:**
```bash
# List fixtures on host
ls -la tests/fixtures/

# Verify expected filename format
# Format: v{ATOP_VERSION}-ubuntu{UBUNTU_VERSION}.raw
# Example: v2.7.1-ubuntu22.04.raw

# Check fixture accessible in container
docker-compose run test-jammy ls -la /tests/fixtures/

# Generate missing fixture
./tests/generate-all-fixtures.sh --version 22.04
```

**Issue: atop Version Mismatch**
```
⚠️  WARNING: Version mismatch (expected 2.7.1, got 2.7.0)
```
**Root Cause:** Ubuntu repo has slightly different atop version than fixture name
**Impact:** Tests continue but field positions might differ slightly
**Solutions:**
```bash
# Check actual version in container
docker-compose run test-jammy atop -V

# If test fails: Regenerate fixture with actual version
# OR: Adjust expected version in test script
# tests/run-test.sh: Change ATOP_VERSION="2.7.1" to match actual
```

### Dynamic Header Detection Failures

**Issue: Fallback Warning in Logs**
```
⚠️  Dynamic header detection failed, using legacy field map
```
**Root Cause:** atop output format changed or header line missing
**Impact:** Script uses hardcoded field positions (may break on new atop versions)
**Solutions:**
```bash
# Capture raw output to debug
atop -P PRG,PRC,PRM,PRD,DSK 1 2 > /tmp/debug.txt

# Check header line format
grep "^PRG" /tmp/debug.txt | head -1
# Expected: "PRG host epoch date time interval pid ppid..."

# Count fields
grep "^PRG" /tmp/debug.txt | head -1 | awk '{print NF}'
# v2.3.0: 16 fields, v2.7.1+: 17+ fields

# If header missing: Update FIELD_MAP in atop-reports.sh for this version
# If header format changed: Update dynamic detection regex
```

**Issue: Container ID Always Null**
```json
{"container_id": null}
```
**Root Cause:** See "Container ID Support Details" section above
**Quick Check:**
```bash
# Verify atop version supports CID
atop -V  # Should be >= 2.7.1

# Check if any process has cgroup info
grep "docker\|lxc\|kubepods" /proc/*/cgroup 2>/dev/null | head
# If empty: No containers running on system

# Run test container
docker run -d --name test nginx:alpine
sudo atop -P PRG 1 1 | grep nginx
# Field 17 should show container ID
```

## Known Constraints
- **Platform:** Linux only (requires `/proc` filesystem)
- **Kernel config:** CONFIG_TASK_IO_ACCOUNTING needed for per-process disk stats
- **Root privileges:** Recommended for full metrics; degrades gracefully without
- **Multipass limitations:** May conflict with VPN, requires nested virtualization on cloud VMs
- **Docker requirements:** Tests require Docker 19.03+ and docker-compose 1.27+

## Code Quality Standards

### Function Length Limit
**Hard requirement:** Functions MUST NOT exceed 150 lines for maintainability and readability.

If refactoring a function that exceeds this limit:
1. Extract logical sections into helper functions
2. Use clear, descriptive function names
3. Maintain single responsibility principle
4. Document helper functions with comments

Example refactoring approach:
```bash
# BEFORE: 200-line parse_atop_output() function

# AFTER: Split into logical components
parse_atop_output() {
    validate_snapshot_file "$snapshot_file"
    parse_process_metrics "$snapshot_file"
    calculate_scores_and_ranks "$temp_dir"
    format_output "$report_file"
}
```

### Checklist for All Changes
1. Preserve ShellCheck cleanliness (zero warnings)
2. Track all temp resources in CLEANUP arrays
3. Test both root and non-root execution
4. Verify trap handlers work with `kill -TERM`
5. Keep functions under 150 lines
6. Update IMPLEMENTATION_v2.0.md for significant changes
7. Run Docker Compose tests on all 4 versions
8. Regenerate fixtures if AWK parsing logic modified
9. Test with both --json and text output formats
10. Verify verbose mode if modifying Container ID logic

## When Modifying This Script
1. Preserve ShellCheck cleanliness (zero warnings)
2. Track all temp resources in CLEANUP arrays
3. Test both root and non-root execution
4. Verify trap handlers work with `kill -TERM`
5. Update IMPLEMENTATION_v2.0.md for significant changes
6. Test replay mode after parsing changes
